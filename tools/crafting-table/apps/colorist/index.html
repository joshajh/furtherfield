<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Colorist - Crafting Table</title>
    <link rel="stylesheet" href="../../shared/styles.css">
    <style>
        .preview-container {
            position: relative;
            background: white;
            border-radius: var(--ff-radius-md);
            padding: var(--ff-spacing-lg);
            box-shadow: var(--ff-shadow-md);
            min-height: 500px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .preview-canvas {
            max-width: 100%;
            height: auto;
            position: relative;
        }

        .color-mode-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: var(--ff-spacing-sm);
        }

        .color-mode-btn {
            padding: var(--ff-spacing-md);
            border: 2px solid var(--ff-gray-200);
            border-radius: var(--ff-radius-sm);
            background: white;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .color-mode-btn:hover {
            border-color: var(--ff-secondary);
        }

        .color-mode-btn.active {
            border-color: var(--ff-secondary);
            background: #e0f2fe;
        }

        .palette-preview {
            display: flex;
            height: 30px;
            margin-bottom: var(--ff-spacing-sm);
            border-radius: var(--ff-radius-sm);
            overflow: hidden;
        }

        .palette-preview div {
            flex: 1;
        }

        .custom-color-input {
            display: flex;
            gap: var(--ff-spacing-sm);
            align-items: center;
        }

        .custom-color-input input[type="color"] {
            width: 50px;
            height: 40px;
            border: none;
            cursor: pointer;
            border-radius: var(--ff-radius-sm);
        }

        .color-list {
            display: flex;
            gap: var(--ff-spacing-sm);
            flex-wrap: wrap;
            margin-top: var(--ff-spacing-sm);
        }

        .color-chip {
            width: 40px;
            height: 40px;
            border-radius: var(--ff-radius-sm);
            border: 2px solid var(--ff-gray-200);
            cursor: pointer;
            position: relative;
        }

        .color-chip-remove {
            position: absolute;
            top: -6px;
            right: -6px;
            width: 16px;
            height: 16px;
            background: var(--ff-gray-700);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div class="ff-container">
        <header class="ff-header">
            <h1>Colorist</h1>
            <p class="subtitle">Apply palettes, gradients, and noise to your assets</p>
            <div class="app-nav">
                <a href="../../index.html">← Back to Apps</a>
                <a href="../grid-generator/index.html">Grid Generator</a>
                <a href="../sprite-generator/index.html">Sprite Generator</a>
            </div>
        </header>

        <div class="ff-card">
            <div class="ff-control-group">
                <label>Load Asset (SVG or PNG)</label>
                <input type="file" id="fileInput" accept=".svg,.png" class="ff-file-input">
                <label for="fileInput" class="ff-file-label">Choose file or drag & drop</label>
                <div id="fileName" style="margin-top: var(--ff-spacing-sm); font-size: 0.875rem; color: var(--ff-gray-600);"></div>
            </div>
        </div>

        <div class="ff-card">
            <h3 style="margin-bottom: var(--ff-spacing-md); color: var(--ff-primary);">Color Mode</h3>
            <div class="color-mode-grid" id="colorModeGrid"></div>
        </div>

        <div class="ff-card">
            <h3 style="margin-bottom: var(--ff-spacing-md); color: var(--ff-primary);">Palette Selection</h3>
            <div id="paletteOptions"></div>
        </div>

        <div class="ff-card" id="customPaletteSection" style="display: none;">
            <h3 style="margin-bottom: var(--ff-spacing-md); color: var(--ff-primary);">Custom Palette</h3>
            <div class="custom-color-input">
                <input type="color" id="customColorPicker" value="#0a2f51">
                <button class="ff-btn ff-btn-secondary" id="addColorBtn">Add Color</button>
            </div>
            <div class="color-list" id="customColorList"></div>
        </div>

        <div class="ff-card" id="advancedControls"></div>

        <div class="ff-card">
            <div class="ff-btn-group">
                <button class="ff-btn ff-btn-primary" id="applyBtn">Apply Colors</button>
                <button class="ff-btn ff-btn-secondary" id="exportSVGBtn">Export SVG</button>
                <button class="ff-btn ff-btn-secondary" id="exportPNGBtn">Export PNG</button>
                <button class="ff-btn ff-btn-secondary" id="exportMetaBtn">Export Metadata</button>
            </div>
        </div>

        <div class="preview-container">
            <div id="preview" class="preview-canvas"></div>
        </div>
    </div>

    <script src="../../shared/config.js"></script>
    <script src="../../shared/utils.js"></script>
    <script>
        // State
        let currentAsset = null;
        let currentMode = 'palette';
        let currentPalette = 'sea';
        let customColors = [];
        let originalSVG = null;

        // Color modes
        const COLOR_MODES = {
            palette: {
                name: 'Solid Palette',
                description: 'Apply colors from a palette to elements'
            },
            gradient: {
                name: 'Gradient',
                description: 'Create smooth color transitions'
            },
            noise: {
                name: 'Generative Noise',
                description: 'Add random color variations'
            },
            tint: {
                name: 'Tint/Overlay',
                description: 'Overlay a color with transparency'
            }
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            initializeColorModes();
            initializePalettes();
            initializeControls();
        });

        function initializeColorModes() {
            const grid = document.getElementById('colorModeGrid');
            Object.entries(COLOR_MODES).forEach(([key, mode]) => {
                const btn = document.createElement('div');
                btn.className = 'color-mode-btn';
                if (key === currentMode) btn.classList.add('active');
                btn.innerHTML = `<strong>${mode.name}</strong><br><small>${mode.description}</small>`;
                btn.onclick = () => selectColorMode(key);
                grid.appendChild(btn);
            });
        }

        function selectColorMode(mode) {
            currentMode = mode;
            document.querySelectorAll('.color-mode-btn').forEach((btn, i) => {
                btn.classList.toggle('active', i === Object.keys(COLOR_MODES).indexOf(mode));
            });
            updateAdvancedControls();
        }

        function initializePalettes() {
            const container = document.getElementById('paletteOptions');
            const palettes = FURTHERFIELD_CONFIG.palettes;

            Object.entries(palettes).forEach(([key, colors]) => {
                const paletteDiv = document.createElement('div');
                paletteDiv.style.marginBottom = 'var(--ff-spacing-md)';

                const radio = document.createElement('input');
                radio.type = 'radio';
                radio.name = 'palette';
                radio.value = key;
                radio.id = `palette-${key}`;
                radio.checked = key === currentPalette;
                radio.onchange = () => {
                    currentPalette = key;
                    document.getElementById('customPaletteSection').style.display = 'none';
                };

                const label = document.createElement('label');
                label.htmlFor = `palette-${key}`;
                label.style.cursor = 'pointer';
                label.style.display = 'flex';
                label.style.alignItems = 'center';
                label.style.gap = 'var(--ff-spacing-sm)';

                const preview = document.createElement('div');
                preview.className = 'palette-preview';
                colors.forEach(color => {
                    const swatch = document.createElement('div');
                    swatch.style.backgroundColor = color;
                    preview.appendChild(swatch);
                });

                const name = document.createElement('span');
                name.textContent = key.charAt(0).toUpperCase() + key.slice(1);

                label.appendChild(radio);
                label.appendChild(preview);
                label.appendChild(name);

                paletteDiv.appendChild(label);
                container.appendChild(paletteDiv);
            });

            // Add custom palette option
            const customDiv = document.createElement('div');
            const customRadio = document.createElement('input');
            customRadio.type = 'radio';
            customRadio.name = 'palette';
            customRadio.value = 'custom';
            customRadio.id = 'palette-custom';
            customRadio.onchange = () => {
                currentPalette = 'custom';
                document.getElementById('customPaletteSection').style.display = 'block';
            };

            const customLabel = document.createElement('label');
            customLabel.htmlFor = 'palette-custom';
            customLabel.textContent = 'Custom Palette';
            customLabel.style.cursor = 'pointer';

            customDiv.appendChild(customRadio);
            customDiv.appendChild(customLabel);
            container.appendChild(customDiv);
        }

        function initializeControls() {
            // File input
            const fileInput = document.getElementById('fileInput');
            fileInput.addEventListener('change', handleFileSelect);

            // Custom color
            document.getElementById('addColorBtn').addEventListener('click', addCustomColor);

            // Export buttons
            document.getElementById('applyBtn').addEventListener('click', applyColors);
            document.getElementById('exportSVGBtn').addEventListener('click', exportSVG);
            document.getElementById('exportPNGBtn').addEventListener('click', exportPNG);
            document.getElementById('exportMetaBtn').addEventListener('click', exportMetadata);
        }

        function handleFileSelect(e) {
            const file = e.target.files[0];
            if (!file) return;

            document.getElementById('fileName').textContent = file.name;

            if (file.name.endsWith('.svg')) {
                FurtherfieldUtils.loadSVG(file).then(svg => {
                    originalSVG = svg.cloneNode(true);
                    displayAsset(svg);
                });
            } else if (file.name.match(/\.(png|jpg|jpeg)$/i)) {
                FurtherfieldUtils.loadImage(file).then(dataUrl => {
                    const img = document.createElement('img');
                    img.src = dataUrl;
                    img.style.maxWidth = '100%';
                    displayAsset(img);
                });
            }
        }

        function displayAsset(element) {
            const preview = document.getElementById('preview');
            preview.innerHTML = '';
            preview.appendChild(element);
            currentAsset = element;
        }

        function addCustomColor() {
            const color = document.getElementById('customColorPicker').value;
            customColors.push(color);
            updateCustomColorList();
        }

        function updateCustomColorList() {
            const list = document.getElementById('customColorList');
            list.innerHTML = '';
            customColors.forEach((color, i) => {
                const chip = document.createElement('div');
                chip.className = 'color-chip';
                chip.style.backgroundColor = color;

                const remove = document.createElement('div');
                remove.className = 'color-chip-remove';
                remove.textContent = '×';
                remove.onclick = () => {
                    customColors.splice(i, 1);
                    updateCustomColorList();
                };

                chip.appendChild(remove);
                list.appendChild(chip);
            });
        }

        function updateAdvancedControls() {
            const container = document.getElementById('advancedControls');
            container.innerHTML = '<h3 style="margin-bottom: var(--ff-spacing-md); color: var(--ff-primary);">Advanced Controls</h3>';

            if (currentMode === 'gradient') {
                container.innerHTML += `
                    <div class="ff-control-group">
                        <label for="gradientAngle">Gradient Angle: <span id="gradientAngleValue">45</span>°</label>
                        <input type="range" id="gradientAngle" class="ff-range" min="0" max="360" value="45">
                    </div>
                `;
                setTimeout(() => {
                    const input = document.getElementById('gradientAngle');
                    input.addEventListener('input', (e) => {
                        document.getElementById('gradientAngleValue').textContent = e.target.value;
                    });
                }, 0);
            } else if (currentMode === 'noise') {
                container.innerHTML += `
                    <div class="ff-control-group">
                        <label for="noiseAmount">Noise Amount: <span id="noiseAmountValue">30</span>%</label>
                        <input type="range" id="noiseAmount" class="ff-range" min="0" max="100" value="30">
                    </div>
                `;
                setTimeout(() => {
                    const input = document.getElementById('noiseAmount');
                    input.addEventListener('input', (e) => {
                        document.getElementById('noiseAmountValue').textContent = e.target.value;
                    });
                }, 0);
            } else if (currentMode === 'tint') {
                container.innerHTML += `
                    <div class="ff-control-group">
                        <label for="tintOpacity">Tint Opacity: <span id="tintOpacityValue">50</span>%</label>
                        <input type="range" id="tintOpacity" class="ff-range" min="0" max="100" value="50">
                    </div>
                    <div class="ff-control-group">
                        <label for="tintColor">Tint Color</label>
                        <input type="color" id="tintColor" value="#0a2f51">
                    </div>
                `;
                setTimeout(() => {
                    const input = document.getElementById('tintOpacity');
                    input.addEventListener('input', (e) => {
                        document.getElementById('tintOpacityValue').textContent = e.target.value;
                    });
                }, 0);
            }
        }

        function applyColors() {
            if (!currentAsset) {
                alert('Please load an asset first');
                return;
            }

            const palette = currentPalette === 'custom' ? customColors : FURTHERFIELD_CONFIG.palettes[currentPalette];

            if (currentMode === 'palette') {
                applyPalette(palette);
            } else if (currentMode === 'gradient') {
                applyGradient(palette);
            } else if (currentMode === 'noise') {
                applyNoise(palette);
            } else if (currentMode === 'tint') {
                applyTint();
            }
        }

        function applyPalette(colors) {
            if (currentAsset.tagName !== 'svg') {
                alert('Palette mode only works with SVG files');
                return;
            }

            const svg = currentAsset;
            const paths = svg.querySelectorAll('path, rect, circle, ellipse, polygon, line');

            paths.forEach((el, i) => {
                const color = colors[i % colors.length];
                if (el.getAttribute('fill') && el.getAttribute('fill') !== 'none') {
                    el.setAttribute('fill', color);
                }
                if (el.getAttribute('stroke') && el.getAttribute('stroke') !== 'none') {
                    el.setAttribute('stroke', color);
                }
            });
        }

        function applyGradient(colors) {
            if (currentAsset.tagName !== 'svg') {
                alert('Gradient mode only works with SVG files');
                return;
            }

            const svg = currentAsset;
            const angle = parseInt(document.getElementById('gradientAngle').value) || 45;

            // Create gradient definition
            let defs = svg.querySelector('defs');
            if (!defs) {
                defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
                svg.insertBefore(defs, svg.firstChild);
            }

            const gradient = document.createElementNS('http://www.w3.org/2000/svg', 'linearGradient');
            gradient.id = 'colorist-gradient';

            // Set gradient angle
            const rad = (angle - 90) * (Math.PI / 180);
            gradient.setAttribute('x1', 50 + 50 * Math.cos(rad) + '%');
            gradient.setAttribute('y1', 50 + 50 * Math.sin(rad) + '%');
            gradient.setAttribute('x2', 50 - 50 * Math.cos(rad) + '%');
            gradient.setAttribute('y2', 50 - 50 * Math.sin(rad) + '%');

            colors.forEach((color, i) => {
                const stop = document.createElementNS('http://www.w3.org/2000/svg', 'stop');
                stop.setAttribute('offset', `${(i / (colors.length - 1)) * 100}%`);
                stop.setAttribute('stop-color', color);
                gradient.appendChild(stop);
            });

            defs.appendChild(gradient);

            // Apply gradient to all fill elements
            const paths = svg.querySelectorAll('path, rect, circle, ellipse, polygon');
            paths.forEach(el => {
                if (el.getAttribute('fill') && el.getAttribute('fill') !== 'none') {
                    el.setAttribute('fill', 'url(#colorist-gradient)');
                }
            });
        }

        function applyNoise(colors) {
            if (currentAsset.tagName !== 'svg') {
                alert('Noise mode only works with SVG files');
                return;
            }

            const svg = currentAsset;
            const noiseAmount = parseInt(document.getElementById('noiseAmount').value) || 30;
            const paths = svg.querySelectorAll('path, rect, circle, ellipse, polygon, line');

            paths.forEach(el => {
                const baseColor = colors[Math.floor(Math.random() * colors.length)];
                const rgb = FurtherfieldUtils.color.hexToRgb(baseColor);

                // Add random noise to each channel
                const noise = noiseAmount / 100 * 255;
                const r = Math.max(0, Math.min(255, rgb.r + (Math.random() - 0.5) * noise));
                const g = Math.max(0, Math.min(255, rgb.g + (Math.random() - 0.5) * noise));
                const b = Math.max(0, Math.min(255, rgb.b + (Math.random() - 0.5) * noise));

                const noisyColor = FurtherfieldUtils.color.rgbToHex(Math.round(r), Math.round(g), Math.round(b));

                if (el.getAttribute('fill') && el.getAttribute('fill') !== 'none') {
                    el.setAttribute('fill', noisyColor);
                }
                if (el.getAttribute('stroke') && el.getAttribute('stroke') !== 'none') {
                    el.setAttribute('stroke', noisyColor);
                }
            });
        }

        function applyTint() {
            if (currentAsset.tagName !== 'svg') {
                alert('Tint mode only works with SVG files');
                return;
            }

            const svg = currentAsset;
            const tintColor = document.getElementById('tintColor').value;
            const opacity = parseInt(document.getElementById('tintOpacity').value) / 100;

            // Create tint overlay
            const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            rect.setAttribute('width', svg.getAttribute('width') || '800');
            rect.setAttribute('height', svg.getAttribute('height') || '800');
            rect.setAttribute('fill', tintColor);
            rect.setAttribute('opacity', opacity);

            svg.appendChild(rect);
        }

        function exportSVG() {
            if (!currentAsset || currentAsset.tagName !== 'svg') {
                alert('No SVG to export');
                return;
            }

            const metadata = FurtherfieldUtils.createMetadata('colorist', 'colored-asset', [currentMode, currentPalette]);
            const filename = FurtherfieldUtils.generateFilename('colorist', 'svg', currentMode);
            FurtherfieldUtils.exportSVG(currentAsset, filename, metadata);
        }

        function exportPNG() {
            if (!currentAsset || currentAsset.tagName !== 'svg') {
                alert('No SVG to export as PNG');
                return;
            }

            const filename = FurtherfieldUtils.generateFilename('colorist', 'png', currentMode);
            FurtherfieldUtils.exportPNG(currentAsset, filename);
        }

        function exportMetadata() {
            const metadata = FurtherfieldUtils.createMetadata('colorist', 'colored-asset', [currentMode, currentPalette]);
            metadata.colorMode = currentMode;
            metadata.palette = currentPalette;
            metadata.colors = currentPalette === 'custom' ? customColors : FURTHERFIELD_CONFIG.palettes[currentPalette];

            const filename = FurtherfieldUtils.generateFilename('colorist-metadata', 'json');
            FurtherfieldUtils.exportJSON(metadata, filename);
        }
    </script>
</body>
</html>
