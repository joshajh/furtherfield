<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tidal Grid Generator - Felixstowe</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            padding: 20px;
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 40px;
        }

        h1 {
            font-size: 2rem;
            color: #333;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #666;
            font-size: 1rem;
        }

        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 30px;
        }

        .control-group {
            margin-bottom: 20px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #333;
        }

        select, input[type="number"], input[type="range"] {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }

        .button-group {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        button {
            flex: 1;
            min-width: 120px;
            padding: 12px 20px;
            background: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background 0.2s;
        }

        button:hover {
            background: #0056b3;
        }

        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        button.secondary {
            background: #6c757d;
        }

        button.secondary:hover {
            background: #545b62;
        }

        .canvas-container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 600px;
        }

        #gridCanvas {
            max-width: 100%;
            height: auto;
        }

        .info {
            background: #e7f3ff;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 20px;
            font-size: 14px;
            line-height: 1.6;
        }

        .info strong {
            display: block;
            margin-bottom: 5px;
        }

        .data-info {
            font-size: 12px;
            color: #666;
            margin-top: 10px;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .range-display {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 5px;
        }

        .range-value {
            font-weight: 600;
            color: #007bff;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Tidal Grid Generator</h1>
            <p class="subtitle">Dynamic grids influenced by Felixstowe's maritime data</p>
        </header>

        <div class="controls">
            <div class="control-group">
                <label for="dataSource">Data Source</label>
                <select id="dataSource">
                    <option value="tidal">Tidal Flow (Real-time tide data)</option>
                    <option value="ships">Ship Movement (Port of Felixstowe)</option>
                </select>
            </div>

            <div class="control-group">
                <div class="range-display">
                    <label for="gridSize">Grid Size</label>
                    <span class="range-value" id="gridSizeValue">20</span>
                </div>
                <input type="range" id="gridSize" min="5" max="50" value="20">
            </div>

            <div class="control-group">
                <div class="range-display">
                    <label for="waveAmplitude">Wave Amplitude</label>
                    <span class="range-value" id="waveAmplitudeValue">20</span>
                </div>
                <input type="range" id="waveAmplitude" min="0" max="50" value="20">
            </div>

            <div class="control-group">
                <div class="range-display">
                    <label for="waveFrequency">Wave Frequency</label>
                    <span class="range-value" id="waveFrequencyValue">3</span>
                </div>
                <input type="range" id="waveFrequency" min="1" max="10" value="3">
            </div>

            <div class="info" id="dataInfo">
                <strong>Current Data:</strong>
                <span id="dataDetails">Loading...</span>
                <div class="data-info" id="dataTimestamp"></div>
            </div>

            <div class="button-group">
                <button id="generateBtn">Generate New Grid</button>
                <button id="exportSVGBtn" class="secondary">Download SVG</button>
                <button id="exportPNGBtn" class="secondary">Download PNG</button>
            </div>
        </div>

        <div class="canvas-container">
            <svg id="gridCanvas" width="800" height="800" viewBox="0 0 800 800">
                <rect width="800" height="800" fill="white"/>
            </svg>
        </div>
    </div>

    <script>
        // Configuration
        const CONFIG = {
            canvasSize: 800,
            strokeColor: '#000000',
            strokeWidth: 1,
            felixstoweCoords: { lat: 52.06, long: 1.35 },
            tidalApiBase: 'https://environment.data.gov.uk/flood-monitoring',
            shipApiBase: 'http://localhost:3000/api/ships'
        };

        // State
        let currentData = null;
        let tidalStation = null;

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            initializeControls();
            findTidalStation();
        });

        function initializeControls() {
            // Range slider displays
            ['gridSize', 'waveAmplitude', 'waveFrequency'].forEach(id => {
                const input = document.getElementById(id);
                const display = document.getElementById(id + 'Value');
                input.addEventListener('input', () => {
                    display.textContent = input.value;
                });
            });

            // Data source change
            document.getElementById('dataSource').addEventListener('change', (e) => {
                if (e.target.value === 'tidal') {
                    fetchTidalData();
                } else {
                    fetchShipData();
                }
            });

            // Generate button
            document.getElementById('generateBtn').addEventListener('click', generateGrid);

            // Export buttons
            document.getElementById('exportSVGBtn').addEventListener('click', exportSVG);
            document.getElementById('exportPNGBtn').addEventListener('click', exportPNG);
        }

        // Find nearest tidal station to Felixstowe
        async function findTidalStation() {
            try {
                const url = `${CONFIG.tidalApiBase}/id/stations?type=TideGauge&lat=${CONFIG.felixstoweCoords.lat}&long=${CONFIG.felixstoweCoords.long}&dist=50`;
                const response = await fetch(url);
                const data = await response.json();

                if (data.items && data.items.length > 0) {
                    tidalStation = data.items[0];
                    console.log('Found tidal station:', tidalStation.label);
                    fetchTidalData();
                } else {
                    throw new Error('No tidal stations found near Felixstowe');
                }
            } catch (error) {
                console.error('Error finding tidal station:', error);
                document.getElementById('dataDetails').textContent = 'Unable to connect to tidal data source';
                // Generate with default values
                generateGridWithDefaults();
            }
        }

        // Fetch tidal data
        async function fetchTidalData() {
            if (!tidalStation) return;

            try {
                document.getElementById('dataDetails').textContent = 'Fetching tidal data...';

                const stationId = tidalStation.stationReference || tidalStation.notation;
                const url = `${CONFIG.tidalApiBase}/id/stations/${stationId}/readings?latest`;
                const response = await fetch(url);
                const data = await response.json();

                if (data.items && data.items.length > 0) {
                    const reading = data.items[0];
                    currentData = {
                        type: 'tidal',
                        value: reading.value,
                        unit: reading.unitName || 'mAOD',
                        dateTime: new Date(reading.dateTime),
                        station: tidalStation.label
                    };

                    updateDataDisplay();
                    generateGrid();
                } else {
                    throw new Error('No readings available');
                }
            } catch (error) {
                console.error('Error fetching tidal data:', error);
                document.getElementById('dataDetails').textContent = 'Using simulated tidal data';
                generateGridWithDefaults();
            }
        }

        // Fetch ship data
        async function fetchShipData() {
            try {
                document.getElementById('dataDetails').textContent = 'Fetching ship movement data...';

                // Try to fetch from local server first
                let shipData;
                try {
                    const response = await fetch(CONFIG.shipApiBase);
                    if (response.ok) {
                        shipData = await response.json();
                    } else {
                        throw new Error('Server not available');
                    }
                } catch (serverError) {
                    console.log('Local server not available, using simulated data');
                    // Fallback to simulated data
                    const shipCount = Math.floor(Math.random() * 20) + 5;
                    const arrivalsCount = Math.floor(shipCount * 0.6);
                    const departuresCount = shipCount - arrivalsCount;

                    shipData = {
                        totalShips: shipCount,
                        arrivals: arrivalsCount,
                        departures: departuresCount,
                        flow: (arrivalsCount - departuresCount),
                        timestamp: new Date().toISOString(),
                        simulated: true
                    };
                }

                currentData = {
                    type: 'ships',
                    totalShips: shipData.totalShips,
                    arrivals: shipData.arrivals,
                    departures: shipData.departures,
                    flow: shipData.flow,
                    dateTime: new Date(shipData.timestamp),
                    simulated: shipData.simulated || false
                };

                updateDataDisplay();
                generateGrid();
            } catch (error) {
                console.error('Error fetching ship data:', error);
                document.getElementById('dataDetails').textContent = 'Unable to fetch ship data';
                generateGridWithDefaults();
            }
        }

        function updateDataDisplay() {
            if (!currentData) return;

            const detailsEl = document.getElementById('dataDetails');
            const timestampEl = document.getElementById('dataTimestamp');

            if (currentData.type === 'tidal') {
                detailsEl.innerHTML = `
                    <strong>Station:</strong> ${currentData.station}<br>
                    <strong>Tide Level:</strong> ${currentData.value.toFixed(2)} ${currentData.unit}
                `;
            } else if (currentData.type === 'ships') {
                const simulatedNote = currentData.simulated ? ' (simulated)' : '';
                detailsEl.innerHTML = `
                    <strong>Total Vessels:</strong> ${currentData.totalShips}${simulatedNote}<br>
                    <strong>Arrivals:</strong> ${currentData.arrivals} | <strong>Departures:</strong> ${currentData.departures}<br>
                    <strong>Net Flow:</strong> ${currentData.flow > 0 ? '+' : ''}${currentData.flow}
                `;
            }

            timestampEl.textContent = `Last updated: ${currentData.dateTime.toLocaleTimeString()} on ${currentData.dateTime.toLocaleDateString()}`;
        }

        function generateGridWithDefaults() {
            currentData = {
                type: 'default',
                value: 0.5,
                dateTime: new Date()
            };
            updateDataDisplay();
            generateGrid();
        }

        function generateGrid() {
            const gridSize = parseInt(document.getElementById('gridSize').value);
            const waveAmplitude = parseInt(document.getElementById('waveAmplitude').value);
            const waveFrequency = parseInt(document.getElementById('waveFrequency').value);

            // Calculate wave parameters based on data source
            let waveParams = calculateWaveParameters(waveAmplitude, waveFrequency);

            // Clear existing grid
            const svg = document.getElementById('gridCanvas');
            while (svg.childNodes.length > 1) {
                svg.removeChild(svg.lastChild);
            }

            // Generate grid with waves
            drawWavyGrid(svg, gridSize, waveParams);
        }

        function calculateWaveParameters(baseAmplitude, baseFrequency) {
            if (!currentData) {
                return {
                    amplitude: baseAmplitude,
                    frequency: baseFrequency,
                    phase: 0
                };
            }

            if (currentData.type === 'tidal') {
                // Map tide level to wave parameters
                // Tide values typically range from -2 to +4 mAOD
                const normalizedTide = (currentData.value + 2) / 6; // Normalize to 0-1

                return {
                    amplitude: baseAmplitude * (0.5 + normalizedTide * 0.5),
                    frequency: baseFrequency * (0.8 + normalizedTide * 0.4),
                    phase: normalizedTide * Math.PI * 2
                };
            } else if (currentData.type === 'ships') {
                // Map ship flow to wave parameters
                // More arrivals = waves coming in (higher frequency)
                // More departures = waves going out (lower frequency)
                const flowRatio = (currentData.flow + 10) / 20; // Normalize to 0-1
                const activityLevel = currentData.totalShips / 20; // Normalize based on expected max

                return {
                    amplitude: baseAmplitude * (0.5 + activityLevel * 0.5),
                    frequency: baseFrequency * (0.5 + flowRatio * 1.0),
                    phase: flowRatio * Math.PI * 2
                };
            }

            return {
                amplitude: baseAmplitude,
                frequency: baseFrequency,
                phase: 0
            };
        }

        function drawWavyGrid(svg, gridSize, waveParams) {
            const cellSize = CONFIG.canvasSize / gridSize;

            // Draw horizontal lines with waves
            for (let i = 0; i <= gridSize; i++) {
                const y = i * cellSize;
                const path = createWavyLine(0, y, CONFIG.canvasSize, y, waveParams, 'horizontal', i);
                svg.appendChild(path);
            }

            // Draw vertical lines with waves
            for (let i = 0; i <= gridSize; i++) {
                const x = i * cellSize;
                const path = createWavyLine(x, 0, x, CONFIG.canvasSize, waveParams, 'vertical', i);
                svg.appendChild(path);
            }
        }

        function createWavyLine(x1, y1, x2, y2, waveParams, direction, lineIndex) {
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            const segments = 100;
            let d = `M ${x1} ${y1}`;

            for (let i = 1; i <= segments; i++) {
                const t = i / segments;
                let x, y;

                if (direction === 'horizontal') {
                    x = x1 + (x2 - x1) * t;
                    // Apply wave distortion to y
                    const wave = Math.sin(t * Math.PI * 2 * waveParams.frequency + waveParams.phase + lineIndex * 0.5) * waveParams.amplitude;
                    y = y1 + wave;
                } else {
                    // Apply wave distortion to x
                    const wave = Math.sin(t * Math.PI * 2 * waveParams.frequency + waveParams.phase + lineIndex * 0.5) * waveParams.amplitude;
                    x = x1 + wave;
                    y = y1 + (y2 - y1) * t;
                }

                d += ` L ${x} ${y}`;
            }

            path.setAttribute('d', d);
            path.setAttribute('stroke', CONFIG.strokeColor);
            path.setAttribute('stroke-width', CONFIG.strokeWidth);
            path.setAttribute('fill', 'none');

            return path;
        }

        function exportSVG() {
            const svg = document.getElementById('gridCanvas');
            const svgData = new XMLSerializer().serializeToString(svg);
            const blob = new Blob([svgData], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);

            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
            const filename = `tidal-grid-${currentData?.type || 'default'}-${timestamp}.svg`;

            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.click();

            URL.revokeObjectURL(url);
        }

        function exportPNG() {
            const svg = document.getElementById('gridCanvas');
            const svgData = new XMLSerializer().serializeToString(svg);
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();

            canvas.width = CONFIG.canvasSize;
            canvas.height = CONFIG.canvasSize;

            img.onload = function() {
                ctx.drawImage(img, 0, 0);
                canvas.toBlob(function(blob) {
                    const url = URL.createObjectURL(blob);
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                    const filename = `tidal-grid-${currentData?.type || 'default'}-${timestamp}.png`;

                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename;
                    link.click();

                    URL.revokeObjectURL(url);
                });
            };

            img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgData)));
        }
    </script>
</body>
</html>
